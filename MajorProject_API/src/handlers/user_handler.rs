use std::env;
use actix_web::{web, HttpResponse, Responder,cookie};
use actix_web::cookie::SameSite;
use bcrypt::{hash, verify, DEFAULT_COST};
use crate::models::user_requests::{CreateUserRequest, CreateUserResponse, CreateUserLogInRequest, CreateUserLogInResponse};
use crate::connect_sql::sql_handler::{DbError, DbPool};
use crate::models::user_requests::{User,LogInUser};
use crate::schema::users as adminD;
use diesel::prelude::*;
use chrono::Utc;
use diesel::sql_query;
use crate::schema::users::dsl::*;
use dotenv::dotenv;
use diesel::{PgConnection, RunQueryDsl};
use diesel::dsl::insert_into;
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use crate::connect_sql::sql_handler::LogInUser as login ;
use crate::connect_sql::no_sql::get_database;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("Employee");

pub async fn migration(mut db_connect: PgConnection) -> HttpResponse {
    match db_connect.run_pending_migrations(MIGRATIONS) {
        Ok(_) => HttpResponse::Created().json("User and database created successfully"),
        Err(e) => {
            eprintln!("Failed to apply migrations: {:?}", e);
            HttpResponse::InternalServerError().json("Failed to apply migrations")
        }
    }
}


pub async fn create_user(pool: web::Data<DbPool>, user_request: web::Json<CreateUserRequest>) -> impl Responder {
    // Hash the password

    let hashed_password = match hash(&user_request.password, DEFAULT_COST) {
        Ok(hash) => hash,
        Err(_) => return HttpResponse::InternalServerError().json("Password hashing failed"),
    };

    // Create a new user instance
    let new_user = User {
        user_id: None, // The ID will be auto-generated by the database
        name: user_request.name.clone(),
        email: user_request.email.clone(),
        company_name: user_request.company_name.clone(),
        role: user_request.role.clone(),
        password: hashed_password,
        database_name: format!("{}_{}_{}", user_request.name.to_lowercase(), user_request.company_name.to_lowercase(), Utc::now().format("%Y%m%d%H%M%S")).replace(" ",""),
        created_at: Some(Utc::now().naive_utc()), // Convert to NaiveDateTime
    };

    // Get a mutable connection from the pool
    let mut conn = match pool.get() {
        Ok(conn) => conn,
        Err(_) => return HttpResponse::InternalServerError().json("Failed to get a database connection"),
    };

    // Insert the new user into the database
    match insert_into(adminD::table)
        .values(&new_user)
        .execute(&mut conn)
    {
        Ok(_) => HttpResponse::Created().json(CreateUserResponse {
            message: "User created successfully".to_string(),
        }),
        Err(e) => {
            eprintln!("Failed to insert user: {:?}", e);
            return HttpResponse::InternalServerError().json("Failed to create user");
        }
    };


    // SQL query to create the new database
    let create_db_sql = format!("CREATE DATABASE {}; ", new_user.database_name);

    println!("{}", create_db_sql);

    // Execute the SQL to create the database
    match sql_query(create_db_sql).execute(&mut conn) {
        Ok(_) => {
            // Log success
            println!("Database created successfully: {}", new_user.database_name);
        }
        Err(e) => {
            eprintln!("Failed to create database: {:?}", e);
            return HttpResponse::InternalServerError().json("Failed to create database");
        }
    };

    // Building database URL for the new database
    dotenv().ok();
    let database_url_admin = format!("{}{}", env::var("DATABASE_URL_ADMIN").expect("DATABASE_URL must be set"), new_user.database_name);
    println!("{}",database_url_admin);

    // tokio::time::sleep(Duration::from_secs(1)).await;
    // Use `spawn_blocking` to prevent blocking the async runtime while connecting to the new database
    let conn_admin = tokio::task::spawn_blocking(move || {
        PgConnection::establish(&database_url_admin)
    })
        .await
        .unwrap(); // Ensure you handle errors properly

    match conn_admin {
        Ok(conn) => {
            let migration_result = migration(conn).await;
            get_database(new_user.database_name.clone()).await;
            let data = login{
                database_name:new_user.database_name.clone(),
            };
            let admin_json = serde_json::to_string(&data).expect("Failed to serialize user");
            let cookies = cookie::Cookie::build("Data",admin_json).path("/").secure(true).http_only(true).same_site(SameSite::None)
                .finish();
            HttpResponse::Created()
                .cookie(cookies)
                .json(serde_json::json!({
        "id": new_user.user_id,
        "email": new_user.email,
        "name": new_user.name,
        "role": new_user.role
    }))

        }
        Err(e) => {
            eprintln!("Failed to connect to the new database: {:?}", e);
            HttpResponse::InternalServerError().json("Failed to create database")
        }
    }
}


pub async fn login_data(pool: web::Data<DbPool>, user_request: web::Json<CreateUserLogInRequest>) -> impl Responder {

    let mut conn = match pool.get() {
        Ok(conn) =>conn,
        Err(_) => return HttpResponse::InternalServerError().json("Failed to get a database connection"),
    };


    let result = adminD::table
        .filter(email.eq(user_request.email.clone()))
        .first::<LogInUser>(&mut conn)
        .optional()  // Use optional to handle the case where no result is found
        .expect("Error while loading admins data");

    match result {
        Some(admin_data) => {
            if verify(&user_request.password, &admin_data.password).unwrap_or(false) {
                let database =  login {
                    database_name : admin_data.database_name.clone(),
                };
                let cookie_data = serde_json::to_string(&database).expect("Failed to serialize user");
                let cookies = cookie::Cookie::build("Data", cookie_data)
                    .path("/")
                    .http_only(true)
                    .same_site(SameSite::None)
                    .secure(true)
                    .finish();
                HttpResponse::Ok().cookie(cookies).json(serde_json::json!({
                    "id": admin_data.user_id,
                    "name": admin_data.name,
                    "email": admin_data.email,
                    "company_name":admin_data.company_name,
                    "role": admin_data.role
                }))
            } else {
                HttpResponse::Created().json(CreateUserLogInResponse { message: "Wrong Password".to_string()})
            }
        }
        None => {
            HttpResponse::InternalServerError().json("Error loading user")
        }
    }
}

